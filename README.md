# Git команды

## Первым делом

1. *Скачать* [Git](https://git-scm.com/downloads)  
2. Настроить Git. 
```
git config user.name "Your name"
git config user.email 'email'
```
3. Зайти в папку, где будет или есть твой __Проект__
4. Прописать команду: 
```
git init
```
5. Создать файлы или папки (если их не было) и начать их отслеживать 
```
git add --all # Если нужно добавить все файлы
git add . # Если нужно добавить текущую папку
git add readme.txt # Если нужно добавить конкретный файл
```  
Теперь файлы и папки отслеживаются. Также это можно проверить с помощью команды: 
```
git status
```

## Вторым делом
1. Сделать коммит: 
```
git commit -m 'Изменения'
```
Он нужен для фиксации изменений, то есть он сохранит все что было сделано и в дальнейшем ты сможешь откатиться к этой версии своего проекта.
2. Также свой __Проект__ можно выкладывть на GitHub. Для этого нужно связать репозиторию на GitHub с локальной. Для этого 
```
git remote add origin 'SSH ссылка на репозиторий в GitHub'
git push origin master или main
```

## Хеш - идентификатор коммита   
Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).  

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит. Git хеширует (преобразует) эту информацию с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования. 

## git log

Вот из каких элементов состоит описание:
   1. Строка из цифр и латинских букв после слова commit — это уже знакомый вам хеш коммита.
   2. Author — имя автора и его электронная почта.
   3. Date — дата и время создания коммита.
   4. Сообщение к коммиту.

## HEAD — всему голова
При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов.   

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).

# Статуты файлов
Статусы untracked/tracked, staged и modified
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.  
Рассмотрим основные.  

* untracked (англ. «неотслеживаемый»)

Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.  

* staged (англ. «подготовленный»)   

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.   

* tracked (англ. «отслеживаемый»)

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.   

* modified (англ. «изменённый»)
   
Состояние modified значит, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

### Вот что ещё важно учесть:   

* Для файлов в состояниях staged и modified обычно не указывается, что они также tracked, потому что это состояние подразумевается.
* Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging. Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.
